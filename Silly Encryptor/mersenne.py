# Reversing the Mersenne PRNG's transformation. Code from:
# https://jazzy.id.au/2010/09/22/cracking_random_number_generators_part_3.html
ONES_32 = 0xFFFFFFFF

def undo_right_xor(y, shift):
    result = 0
    for i in range(0, 32, shift):
        partMask = ((ONES_32 << (32 - shift)) & ONES_32) >> i
        part = y & partMask
        y ^= part >> shift
        result |= part
    return result


def undo_left_xor(y, shift, mask):
    result = 0
    for i in range(0, 32, shift):
        partMask = (ONES_32 >> (32 - shift)) << i
        part = y & partMask
        y ^= (part << shift) & mask
        result |= part
    return result


def transform(y):
    y ^= y >> 11
    y ^= (y << 7) & ONES_32 & 0x9D2C5680
    y ^= (y << 15) & ONES_32 & 0xEFC60000
    y ^= y >> 18
    return y


def undo_transform(y):
    y = undo_right_xor(y, 18)
    y = undo_left_xor(y, 15, 0xEFC60000)
    y = undo_left_xor(y, 7, 0x9D2C5680)
    y = undo_right_xor(y, 11)
    return y


# A partial recreation of Python's random number generator. Code taken from:
# https://github.com/python/cpython/blob/master/Lib/random.py
# https://github.com/python/cpython/blob/master/Modules/_randommodule.c

# Period parameters
N = 624
M = 397
MATRIX_A   = 0x9908B0DF  # constant vector a
UPPER_MASK = 0x80000000  # most significant w-r bits
LOWER_MASK = 0x7FFFFFFF  # least significant r bits
mag01 = [0, MATRIX_A]    # mag01[x] = x * MATRIX_A  for x=0,1

class Rand():
    def __init__(self, state, index=0):
        assert len(state) == N
        self.state = state
        self.index = index

    def randrange(self, start, stop):
        return start + self._randbelow_with_getrandbits(stop - start)

    def _randbelow_with_getrandbits(self, n):
        getrandbits = self.getrandbits
        k = n.bit_length()  # don't use (n-1) here because n can be 1
        r = getrandbits(k)          # 0 <= r < 2**k
        while r >= n:
            r = getrandbits(k)
        return r

    def getrandbits(self, k):
        if k <= 32:
            return self.genrand_int32() >> (32 - k)

    def genrand_int32(self):
        mt = self.state
        if self.index >= N:
            for kk in range(N - M):
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK)
                mt[kk] = mt[kk + M] ^ (y >> 1) ^ mag01[y & 1]

            for kk in range(N - M, N - 1):
                y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK)
                mt[kk] = mt[kk + (M - N)] ^ (y >> 1) ^ mag01[y & 1]

            y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK)
            mt[N - 1] = mt[M - 1] ^ (y >> 1) ^ mag01[y & 1]
            self.index = 0

        y = mt[self.index]
        self.index += 1
        return transform(y)


# Figures out the state of Python's PRNG.
# Input: A list of at least N consecutive numbers generated by random.randrange(0, 2**32-1)
def reverse(rolls):
    urolls = [undo_transform(r) for r in rolls]

    for i in range(len(rolls) - N):
        r = Rand(urolls[i:i + N], index=N)
        correct = True
        for j in range(len(rolls) - (i + N)):
            if r.randrange(0, 2**32-1) != rolls[i + N + j]:
                correct = False
                break
        if correct:
            print("Found at " + str(i))
            return r


if __name__ == "__main__":
    import random

    # Scramble the position of the state of the PRNG by generating a random
    # number of numbers
    for _ in range(random.randint(1, 4*N)):
        # It's arbitrary what range we generate, but this ensures that 1
        # element of the state is used per generation.
        random.randrange(0, 2**32-1)

    # Figure out the state of Python's `random`
    r = reverse([random.randrange(0, 2**32-1) for _ in range(2 * N)])

    # Test our guess
    python_rand = [random.randrange(0, 2**32-1) for _ in range(4*N)]
    our_rand    = [r.randrange(0, 2**32-1) for _ in range(4*N)]

    if python_rand == our_rand:
        print("Guess was correct.")
    else:
        print("Guess was incorrect.")
